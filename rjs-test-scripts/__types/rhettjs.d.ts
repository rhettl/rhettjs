// RhettJS Core API Type Definitions
// Auto-generated by TypeGenerator using Java Reflection
// Last updated: 2025-12-26T15:36:25.685424

// ============================================================================
// Runtime API
// ============================================================================

/** Runtime environment and lifecycle control */
declare const Runtime: {
    /** Environment constants */
    env: {
        /** Maximum number of worker threads available (determined at boot based on CPU cores, max 4) */
        MAX_WORKER_THREADS: number;
        /** Minecraft ticks per second (always 20) */
        TICKS_PER_SECOND: number;
        /** Whether debug logging is enabled in rhettjs.json config */
        IS_DEBUG: boolean;
        /** RhettJS version */
        RJS_VERSION: string;
    };
    /** Stop script execution and cancel all pending scheduled tasks */
    exit(): void;

    /**
     * Set the event loop timeout for the current script execution.
     * Must be called before any async operations (task/wait).
     * Default: 60000ms (60 seconds)
     *
     * WARNING: Setting this too high can cause server hangs if scripts don't complete.
     * Use with caution.
     *
     * @param timeoutMs Maximum time to wait for async operations in milliseconds
     *
     * @example
     * Runtime.setEventLoopTimeout(120000); // 2 minute timeout for slow data migration
     */
    setEventLoopTimeout(timeoutMs: number): void;

    /**
     * Inspect a Java object using reflection to see available methods and fields.
     * Useful for exploring Minecraft API objects from JavaScript.
     *
     * @param obj The Java object to inspect
     * @returns Object containing class info, methods, fields, and superclass chain
     */
    inspect(obj: any): {
        class: string;
        simpleName: string;
        methods: string[];
        fields: string[];
        superclasses: string[];
        interfaces: string[];
    };
};

// ============================================================================
// Core APIs
// ============================================================================

// @ts-ignore
declare const console: {
    log(...messages: any[]): void;
    debug(...messages: any[]): void;
    error(...messages: any[]): void;
    warn(...messages: any[]): void;
};


declare const logger: {
    info(message: string): void;
    debug(message: string): void;
    error(message: string, arg1: any): void;
    error(message: string): void;
    warn(message: string): void;
};


/**
 * Execute a function on a worker thread.
 * Returns a Promise that resolves when the worker completes.
 *
 * Workers run in isolated Context but CAN access parent scope via closures.
 * ⚠️ AVOID sharing mutable state - workers run concurrently, causing race conditions!
 * 
 * Workers CAN use: console, logger, Structure, task() (nested), Runtime
 * Workers CANNOT use: wait(), player, world, server APIs
 *
 * @param callback Function to execute on worker thread
 * @param args Arguments to pass to the callback (must be primitives or JS objects)
 * @returns Promise that resolves with the callback's return value
 *
 * @example Pass data as arguments (recommended)
 * const data = [1, 2, 3];
 * task((arr) => arr.map(x => x * 2), data).then(result => {
 *     console.log(result); // [2, 4, 6]
 * });
 *
 * @example Using closures (works, but avoid mutable state)
 * const MULTIPLIER = 10;
 * task((val) => val * MULTIPLIER, 5).then(console.log); // 50
 *
 * @example ⚠️ AVOID - Race condition with shared mutable state
 * const arr = [];
 * task(() => arr.push(1));  // DON'T DO THIS - concurrent modification!
 *
 * @example Nested tasks (automatically runs immediately on same thread)
 * task(() => {
 *     return task(() => "inner"); // Runs immediately, returns resolved Promise
 * }).then(result => console.log(result)); // "inner"
 */
declare function task<T = any>(
    callback: (...args: any[]) => T,
    ...args: any[]
): Promise<T>;

/**
 * Wait for a specified number of game ticks before resolving.
 * Returns a Promise that resolves after N ticks (20 ticks = 1 second).
 *
 * ONLY works on the server thread (NOT in workers).
 * Workers should exit and use .thenWait() to return to server thread.
 *
 * @param ticks Number of game ticks to wait (minimum 1)
 * @returns Promise that resolves with undefined after the delay
 *
 * @example Basic wait
 * wait(20).then(() => {
 *     console.log("1 second later");
 * });
 *
 * @example Sequential waits
 * wait(10).then(() => {
 *     console.log("After 10 ticks");
 *     return wait(10);
 * }).then(() => {
 *     console.log("After 20 ticks total");
 * });
 *
 * @example Combining with task
 * task(() => Structure.read("house"))
 *     .thenWait(20) // Wait 1 second after reading
 *     .then(data => console.log("Delayed result:", data));
 */
declare function wait(ticks: number): Promise<void>;

/**
 * Promise extensions for chaining async operations.
 * Added by RhettJS to Promise.prototype.
 */
interface Promise<T> {
    /**
     * Chain to a worker thread.
     * If the Promise resolves with a value, it's passed to the callback.
     * If the Promise resolves with undefined, the callback is called with no arguments.
     *
     * @param callback Function to execute on worker thread
     * @returns Promise that resolves with the worker's return value
     *
     * @example With value
     * task(() => "step1")
     *     .thenTask(result => result + "-step2")
     *     .then(result => console.log(result)); // "step1-step2"
     *
     * @example With undefined (no argument)
     * Promise.resolve()
     *     .thenTask(() => "from-worker")
     *     .then(result => console.log(result)); // "from-worker"
     */
    thenTask<U>(callback: (value: T) => U): Promise<U>;

    /**
     * Chain with a tick delay, passing the result through.
     * Equivalent to: .then(result => wait(ticks).then(() => result))
     *
     * @param ticks Number of game ticks to wait
     * @returns Promise that resolves with the same value after the delay
     *
     * @example
     * task(() => 42)
     *     .thenWait(20) // Wait 1 second
     *     .then(result => console.log(result)); // 42 (preserved)
     */
    thenWait(ticks: number): Promise<T>;
}

// ============================================================================
// Structure API
// ============================================================================

interface NBTFilterResult {
    value: any;
    path: (string | number)[];
    parent: any;
}

// Minecraft 1.21.1 NBT Structure Format
// Based on: https://minecraft.wiki/w/Structure_file
// This file defines the official Minecraft structure NBT format.
// It is version-specific and should be updated when targeting new Minecraft versions.

/**
 * Block state definition in the palette.
 * Represents a unique block type and its properties.
 */
interface BlockState {
    /**
     * Block identifier (e.g., "minecraft:stone", "minecraft:oak_stairs")
     */
    Name: string;
    
    /**
     * Block state properties (e.g., {"facing": "north", "half": "bottom"})
     * Only present if the block has properties different from defaults.
     */
    Properties?: { [key: string]: string };
}

/**
 * Individual block placement within the structure.
 * References a palette entry and specifies position.
 */
interface BlockPlacement {
    /**
     * Index into the palette array.
     * Determines which block type is placed at this position.
     */
    state: number;
    
    /**
     * Position within the structure [x, y, z].
     * Coordinates are relative to structure origin (0,0,0).
     */
    pos: [number, number, number];
    
    /**
     * Block entity NBT data (optional).
     * Present for blocks like chests, signs, spawners, etc.
     * Contains block-specific data (e.g., chest inventory, sign text).
     */
    nbt?: { [key: string]: any };
}

/**
 * Entity within the structure.
 * Includes both exact position and block-aligned position.
 */
interface StructureEntity {
    /**
     * Exact entity position as doubles [x, y, z].
     * Can have fractional coordinates for precise placement.
     */
    pos: [number, number, number];
    
    /**
     * Block-aligned position as integers [x, y, z].
     * Used for block-relative positioning.
     */
    blockPos: [number, number, number];
    
    /**
     * Entity NBT data.
     * Must include 'id' field with entity type.
     */
    nbt: {
        /**
         * Entity identifier (e.g., "minecraft:painting", "minecraft:armor_stand")
         */
        id: string;
        
        /**
         * Entity-specific NBT data.
         * Varies by entity type (e.g., painting variant, armor stand pose).
         */
        [key: string]: any;
    };
}

/**
 * Complete Minecraft structure file format (1.21.1).
 * Represents the NBT structure saved by structure blocks.
 * 
 * @example Reading a structure
 * ```javascript
 * const data = Structure.read("village/houses/house_1");
 * console.log(`Size: ${data.size[0]}x${data.size[1]}x${data.size[2]}`);
 * console.log(`Blocks: ${data.blocks.length}`);
 * console.log(`Palette entries: ${data.palette.length}`);
 * ```
 * 
 * @example Modifying blocks
 * ```javascript
 * const data = Structure.read("my_structure");
 * // Change all stone to diamond blocks
 * data.palette.forEach((state, index) => {
 *     if (state.Name === "minecraft:stone") {
 *         data.palette[index] = { Name: "minecraft:diamond_block" };
 *     }
 * });
 * Structure.write("my_structure", data);
 * ```
 */
interface StructureData {
    /**
     * Minecraft data version number.
     * Used for data migration between versions.
     * For 1.21.1, this is typically 3953+.
     */
    DataVersion: number;
    
    /**
     * Structure dimensions [x, y, z].
     * Maximum size is 48x48x48 (structure block limit).
     */
    size: [number, number, number];
    
    /**
     * Block palette - array of unique block states.
     * Each block placement references an index in this array.
     * Reduces file size by avoiding duplicate block state definitions.
     */
    palette: BlockState[];
    
    /**
     * Multiple palettes (optional).
     * Used by some vanilla structures (e.g., shipwrecks) for randomization.
     * When present, one palette is randomly selected during placement.
     */
    palettes?: BlockState[][];
    
    /**
     * Block placements within the structure.
     * Each entry specifies a block type (via palette index) and position.
     * Air blocks are typically omitted to reduce file size.
     */
    blocks: BlockPlacement[];
    
    /**
     * Entities within the structure (optional).
     * Includes paintings, armor stands, item frames, etc.
     */
    entities?: StructureEntity[];
    
    /**
     * Structure author (pre-1.13 only, deprecated).
     * Name of the player who created the structure.
     * No longer used in modern versions.
     */
    author?: string;
}



declare const Structure: {
    list(pool?: string): string[];
    write(name: string, data: StructureData): void;
    read(name: string): StructureData | null;
    nbt: {
        some(data: any, predicate: (value: any, path: (string | number)[], parent: any) => boolean): boolean;
        filter(data: any, predicate: (value: any, path: (string | number)[], parent: any) => boolean): NBTFilterResult[];
        find(data: any, predicate: (value: any, path: (string | number)[], parent: any) => boolean): NBTFilterResult | null;
        forEach(data: any, callback: (value: any, path: (string | number)[], parent: any) => void): void;
    };
};


// ============================================================================
// Store API (Ephemeral Key-Value Storage)
// ============================================================================

/**
 * Namespaced store for organizing related data.
 * Provides scoped key-value operations within a namespace.
 */
interface NamespacedStore {
    /** Store a value under a key in this namespace */
    set(key: string, value: any): void;
    /** Retrieve a value by key from this namespace */
    get(key: string): any;
    /** Check if a key exists in this namespace */
    has(key: string): boolean;
    /** Delete a key from this namespace */
    delete(key: string): boolean;
    /** Clear all keys in this namespace only */
    clear(): void;
    /** Get all keys in this namespace */
    keys(): string[];
    /** Get the number of items in this namespace */
    size(): number;
    /** Get all entries in this namespace as a map */
    entries(): Record<string, any>;
}

/**
 * Ephemeral key-value store for sharing data across script executions.
 * Data persists in memory until server restart.
 *
 * @example
 * const positions = Store.namespace('positions');
 * positions.set('player1:pos1', { x: 100, y: 64, z: 200 });
 * const pos = positions.get('player1:pos1');
 */
declare const Store: {
    /** Create a namespaced store for organizing related data */
    namespace(namespace: string): NamespacedStore;
    /** Get all namespaces currently in use */
    namespaces(): string[];
    /** Clear all data across all namespaces */
    clearAll(): void;
    /** Get total number of items across all namespaces */
    size(): number;
};

// ============================================================================
// World API
// ============================================================================

declare const World: {
    blocksReplaceLargeVanilla(namespace: string, name: string, typeOverrides?: Record<string, string>): { piecesModified: number; warnings: string[] };
    grab(world: string, x1: number, y1: number, z1: number, x2: number, y2: number, z2: number): Record<string, any> | null;
    getLargeMetadata(namespace: string, name: string): { requires: string[]; pieceSize: any; gridSize: any; totalSize: any; pieceCount: number; location: string } | null;
    blocksListLarge(namespace: string, name: string): Record<string, number>;
    blocksReplaceLarge(namespace: string, name: string, replacementMap: Record<string, string>): number;
    grabToFile(world: string, x1: number, y1: number, z1: number, x2: number, y2: number, z2: number, filename: string, subdirectory?: string): string;
    grabLarge(world: string, x1: number, y1: number, z1: number, x2: number, y2: number, z2: number, name: string, pieceSize?: number[], namespace?: string): { name: string; namespace: string; pieces: number; requires: string[]; path: string };
    listLarge(namespace?: string): Array<{ namespace: string; name: string; location: string }>;
    placeLarge(world: string, x: number, y: number, z: number, namespace: string, name: string, rotation?: number): { piecesPlaced: number; blocksPlaced: number; metadata: any; rotation: number; position: any };
};

// ============================================================================
// Command API
// ============================================================================

/** Command execution result */
interface CommandResult {
    success: boolean;
    resultCount: number;
    feedback: string[];
    error: string | null;
}

/** Command execution API (available in command contexts and /rjs run) */
declare const Command: {
    /** Execute command as the caller (player). Returns Promise. */
    execute(command: string): Promise<CommandResult>;
    /** Execute command at specific position. Returns Promise. */
    executeAt(x: number, y: number, z: number, command: string): Promise<CommandResult>;
    /** Execute command as server/console. Returns Promise. */
    executeAsServer(command: string): Promise<CommandResult>;
    /** Get command suggestions for partial command. Returns Promise. */
    suggest(partialCommand: string): Promise<string[]>;
};

// ============================================================================
// Event APIs
// ============================================================================

/** Block event data passed to block event handlers */
interface BlockEvent {
    position: { x: number; y: number; z: number; dimension: string };
    block: { id: string; properties: Record<string, string> };
    player?: any;  // ServerPlayer object (use Runtime.inspect() to explore)
    playerData?: { name: string; uuid: string; isCreative: boolean };
    isRightClick?: boolean;
    item?: { id: string; count: number; displayName?: string; nbt?: Record<string, any> };
    face?: string;
    placedAgainst?: { x: number; y: number; z: number };
    experience?: number;
    drops?: Array<{ id: string; count: number }>;

    // Messaging methods (same as Caller API, compatible with MessageBuffer)
    sendMessage(message: string): void;
    sendSuccess(message: string): void;
    sendError(message: string): void;
    sendWarning(message: string): void;
    sendInfo(message: string): void;
    sendRaw(json: string): void;
    isPlayer(): boolean;

    // Event cancellation
    /** Cancel this event to prevent default behavior (e.g., block break) */
    cancel(): void;
    /** Whether this event has been cancelled */
    cancelled: boolean;
}

/** Command execution context (consistent with Caller and event APIs) */
interface CommandContext {
    /** The player who executed the command (null if console/command block) */
    player?: any;  // ServerPlayer object
    /** The command source (CommandSourceStack) */
    source: any;
    /** Get the player's name or 'Server' if not a player */
    playerName: string;
    /** Unwrap to get the raw Brigadier CommandContext */
    unwrap(): any;

    // Messaging methods (consistent with Caller and event APIs)
    /** Send a success message (green) */
    sendSuccess(message: string): void;
    /** Send an error message (red) */
    sendError(message: string): void;
    /** Send a normal message */
    sendMessage(message: string): void;
}

/** Command builder for creating typed commands */
interface CommandBuilder {
    types: any; // ArgumentTypeWrappers
    addArgument(name: string, type: any): void;
    setExecutor(handler: (context: CommandContext) => number): void;
    requiresPermission(level: number): void;
}

/** Runtime event handlers (available in server/ and scripts/) */
declare const ServerEvents: {
    /** Register handler for item use events */
    itemUse(handler: (event: any) => void): void;
    /** Register basic command with string arguments */
    basicCommand(commandName: string, handler: (args: string) => void): void;
    /** Register full Brigadier command with typed arguments */
    command(commandName: string, builderFunction: (cmd: CommandBuilder) => void): void;
    /** Register handler for block right-click events */
    blockRightClicked(handler: (event: BlockEvent) => void): void;
    blockRightClicked(blockFilter: string, handler: (event: BlockEvent) => void): void;
    /** Register handler for block left-click events */
    blockLeftClicked(handler: (event: BlockEvent) => void): void;
    blockLeftClicked(blockFilter: string, handler: (event: BlockEvent) => void): void;
    /** Register handler for block placement events */
    blockPlaced(handler: (event: BlockEvent) => void): void;
    blockPlaced(blockFilter: string, handler: (event: BlockEvent) => void): void;
    /** Register handler for block breaking events */
    blockBroken(handler: (event: BlockEvent) => void): void;
    blockBroken(blockFilter: string, handler: (event: BlockEvent) => void): void;
};

// ============================================================================
// Utility Script APIs (available in /rjs run)
// ============================================================================

/** Raycast result from Caller.raycast() */
interface RaycastResult {
    hit: boolean;
    type: 'block' | 'miss' | 'unknown';
    x?: number;
    y?: number;
    z?: number;
    block?: string;
    face?: 'up' | 'down' | 'north' | 'south' | 'east' | 'west';
    distance: number;
}

declare const Caller: {
    // Property-based access (preferred, matches event pattern)
    /** The caller's name (player name or \"Server\") */
    readonly name: string;
    /** The caller's position and dimension */
    readonly position: { x: number; y: number; z: number; dimension: string };
    /** The caller's rotation (null if not an entity) */
    readonly rotation: { yaw: number; pitch: number } | null;
    /** The player object (null if caller is console/command block) */
    readonly player: any | null;

    // Helper methods
    sendMessage(message: string): void;
    sendSuccess(message: string): void;
    sendError(message: string): void;
    sendWarning(message: string): void;
    sendInfo(message: string): void;
    sendRaw(json: string): void;
    raycast(maxDistance?: number, includeFluid?: boolean): RaycastResult | null;

    // Deprecated methods (kept for backward compatibility)
    /** @deprecated Use Caller.player != null instead */
    isPlayer(): boolean;
    /** @deprecated Use Caller.position.dimension instead */
    getDimension(): string;
    /** @deprecated Use Caller.name instead */
    getName(): string;
    /** @deprecated Use Caller.position instead */
    getPosition(): { x: number; y: number; z: number; dimension: string };
    /** @deprecated Use Caller.rotation instead */
    getRotation(): { yaw: number; pitch: number } | null;
};

declare const Args: string[];


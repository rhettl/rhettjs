package com.rhett.rhettjs.engine

import com.rhett.rhettjs.api.*
import java.nio.file.Files
import java.nio.file.Path
import java.time.LocalDateTime

/**
 * TypeScript definition generator for RhettJS APIs.
 * Designed to run in-game via /rjs probe with full runtime context.
 *
 * Generates accurate TypeScript definitions by introspecting:
 * - Core APIs (console, logger, task, schedule) via reflection
 * - Structure API and NBT utilities via reflection
 * - JavaScript globals from globals/ directory via Rhino introspection
 * - Event APIs
 */
object TypeGenerator {

    /**
     * Generate TypeScript definitions for RhettJS APIs.
     * Must be called from within the game runtime (via /rjs probe).
     *
     * @param outputDir Directory to write the generated files (e.g., rjs/__types/)
     * @param scriptsDir Scripts directory containing globals/ subdirectory
     * @param category Script category to introspect (default: UTILITY for full API surface)
     * @return GenerationResult with status and file count
     */
    fun generate(
        outputDir: Path,
        scriptsDir: Path,
        category: ScriptCategory = ScriptCategory.UTILITY
    ): GenerationResult {
        return try {
            // Create output directory if it doesn't exist
            if (!Files.exists(outputDir)) {
                Files.createDirectories(outputDir)
            }

            // Introspect APIs from runtime
            val baseApis = ScriptEngine.introspectAvailableApis(category)

            // Categorize APIs
            val coreApis = baseApis.filter { (name, _) ->
                name in listOf("console", "logger", "task", "schedule")
            }

            val constants = baseApis.filter { (name, _) ->
                name in listOf("MAX_WORKER_THREADS", "TICKS_PER_SECOND", "IS_DEBUG")
            }

            val structureApi = baseApis.filter { (name, _) -> name == "Structure" }
            val eventApis = baseApis.filter { (name, _) -> name.endsWith("Events") }

            // Globals are everything else (excluding standard JS objects)
            val standardJsObjects = setOf(
                "Object", "Array", "String", "Number", "Boolean", "Date", "Math", "JSON",
                "RegExp", "Error", "Function", "undefined", "NaN", "Infinity",
                "parseInt", "parseFloat", "isNaN", "isFinite", "decodeURI", "decodeURIComponent",
                "encodeURI", "encodeURIComponent", "escape", "unescape", "eval"
            )

            val globals = baseApis.filter { (name, _) ->
                name !in coreApis.keys &&
                name !in constants.keys &&
                name !in structureApi.keys &&
                name !in eventApis.keys &&
                name !in standardJsObjects
            }

            // Generate files
            var filesGenerated = 0

            generateCoreTypes(outputDir.resolve("rhettjs.d.ts"), coreApis, structureApi, eventApis)
            filesGenerated++

            generateReadme(outputDir.resolve("README.md"), false)
            filesGenerated++

            generateJsConfigTemplate(outputDir.resolve("jsconfig.json.template"))
            filesGenerated++

            GenerationResult.Success(
                filesGenerated = filesGenerated,
                coreApiCount = coreApis.size + constants.size + structureApi.size + eventApis.size + 2, // +2 for Caller and Args
                globalsCount = 0
            )

        } catch (e: Exception) {
            GenerationResult.Error(e.message ?: "Unknown error", e)
        }
    }

    /**
     * Generate core TypeScript definitions file using reflection.
     */
    private fun generateCoreTypes(
        file: Path,
        coreApis: Map<String, String>,
        structureApi: Map<String, String>,
        eventApis: Map<String, String>
    ) {
        val content = buildString {
            appendLine("// RhettJS Core API Type Definitions")
            appendLine("// Auto-generated by TypeGenerator using Java Reflection")
            appendLine("// Last updated: ${LocalDateTime.now()}")
            appendLine()

            // Runtime API
            appendLine("// ============================================================================")
            appendLine("// Runtime API")
            appendLine("// ============================================================================")
            appendLine()
            appendLine("/** Runtime environment and lifecycle control */")
            appendLine("declare const Runtime: {")
            appendLine("    /** Environment constants */")
            appendLine("    env: {")
            appendLine("        /** Maximum number of worker threads available (determined at boot based on CPU cores, max 4) */")
            appendLine("        MAX_WORKER_THREADS: number;")
            appendLine("        /** Minecraft ticks per second (always 20) */")
            appendLine("        TICKS_PER_SECOND: number;")
            appendLine("        /** Whether debug logging is enabled in rhettjs.json config */")
            appendLine("        IS_DEBUG: boolean;")
            appendLine("        /** RhettJS version */")
            appendLine("        RJS_VERSION: string;")
            appendLine("    };")
            appendLine("    /** Stop script execution and cancel all pending scheduled tasks */")
            appendLine("    exit(): void;")
            appendLine()
            appendLine("    /**")
            appendLine("     * Set the event loop timeout for the current script execution.")
            appendLine("     * Must be called before any async operations (task/wait).")
            appendLine("     * Default: 60000ms (60 seconds)")
            appendLine("     *")
            appendLine("     * WARNING: Setting this too high can cause server hangs if scripts don't complete.")
            appendLine("     * Use with caution.")
            appendLine("     *")
            appendLine("     * @param timeoutMs Maximum time to wait for async operations in milliseconds")
            appendLine("     *")
            appendLine("     * @example")
            appendLine("     * Runtime.setEventLoopTimeout(120000); // 2 minute timeout for slow data migration")
            appendLine("     */")
            appendLine("    setEventLoopTimeout(timeoutMs: number): void;")
            appendLine()
            appendLine("    /**")
            appendLine("     * Inspect a Java object using reflection to see available methods and fields.")
            appendLine("     * Useful for exploring Minecraft API objects from JavaScript.")
            appendLine("     *")
            appendLine("     * @param obj The Java object to inspect")
            appendLine("     * @returns Object containing class info, methods, fields, and superclass chain")
            appendLine("     */")
            appendLine("    inspect(obj: any): {")
            appendLine("        class: string;")
            appendLine("        simpleName: string;")
            appendLine("        methods: string[];")
            appendLine("        fields: string[];")
            appendLine("        superclasses: string[];")
            appendLine("        interfaces: string[];")
            appendLine("    };")
            appendLine("};")
            appendLine()

            // Core APIs - dynamically generated via reflection
            if (coreApis.isNotEmpty()) {
                appendLine("// ============================================================================")
                appendLine("// Core APIs")
                appendLine("// ============================================================================")
                appendLine()

                coreApis.forEach { (name, _) ->
                    val apiDefinition = generateApiDefinition(name)
                    if (apiDefinition != null) {
                        appendLine(apiDefinition)
                        appendLine()
                    }
                }
            }

            // Structure API - dynamically generated via reflection
            if (structureApi.isNotEmpty()) {
                appendLine("// ============================================================================")
                appendLine("// Structure API")
                appendLine("// ============================================================================")
                appendLine()

                val structureDefinition = generateStructureApiDefinition()
                if (structureDefinition != null) {
                    appendLine(structureDefinition)
                    appendLine()
                }
            }

            // Store API - dynamically generated via reflection
            appendLine("// ============================================================================")
            appendLine("// Store API (Ephemeral Key-Value Storage)")
            appendLine("// ============================================================================")
            appendLine()
            val storeDefinition = generateStoreApiDefinition()
            if (storeDefinition != null) {
                appendLine(storeDefinition)
                appendLine()
            }

            // World API - dynamically generated via reflection
            val worldApiDefinition = generateWorldApiDefinition()
            if (worldApiDefinition != null) {
                appendLine("// ============================================================================")
                appendLine("// World API")
                appendLine("// ============================================================================")
                appendLine()
                appendLine(worldApiDefinition)
                appendLine()
            }

            // Command API - dynamically generated via reflection
            val commandApiDefinition = generateCommandApiDefinition()
            if (commandApiDefinition != null) {
                appendLine("// ============================================================================")
                appendLine("// Command API")
                appendLine("// ============================================================================")
                appendLine()
                appendLine(commandApiDefinition)
                appendLine()
            }

            // Event APIs - dynamically generated via reflection
            if (eventApis.isNotEmpty()) {
                appendLine("// ============================================================================")
                appendLine("// Event APIs")
                appendLine("// ============================================================================")
                appendLine()
                eventApis.forEach { (name, _) ->
                    val eventApiDefinition = generateEventApiDefinition(name)
                    if (eventApiDefinition != null) {
                        appendLine(eventApiDefinition)
                        appendLine()
                    } else {
                        appendLine("declare const $name: any;  // Failed to generate types")
                        appendLine()
                    }
                }
            }

            // Utility Script Context APIs
            appendLine("// ============================================================================")
            appendLine("// Utility Script APIs (available in /rjs run)")
            appendLine("// ============================================================================")
            appendLine()

            // Generate Caller API with property-based access (matches event pattern)
            appendLine("/** Raycast result from Caller.raycast() */")
            appendLine("interface RaycastResult {")
            appendLine("    hit: boolean;")
            appendLine("    type: 'block' | 'miss' | 'unknown';")
            appendLine("    x?: number;")
            appendLine("    y?: number;")
            appendLine("    z?: number;")
            appendLine("    block?: string;")
            appendLine("    face?: 'up' | 'down' | 'north' | 'south' | 'east' | 'west';")
            appendLine("    distance: number;")
            appendLine("}")
            appendLine()
            appendLine("declare const Caller: {")
            appendLine("    // Property-based access (preferred, matches event pattern)")
            appendLine("    /** The caller's name (player name or \\\"Server\\\") */")
            appendLine("    readonly name: string;")
            appendLine("    /** The caller's position and dimension */")
            appendLine("    readonly position: { x: number; y: number; z: number; dimension: string };")
            appendLine("    /** The caller's rotation (null if not an entity) */")
            appendLine("    readonly rotation: { yaw: number; pitch: number } | null;")
            appendLine("    /** The player object (null if caller is console/command block) */")
            appendLine("    readonly player: any | null;")
            appendLine()
            appendLine("    // Helper methods")
            appendLine("    sendMessage(message: string): void;")
            appendLine("    sendSuccess(message: string): void;")
            appendLine("    sendError(message: string): void;")
            appendLine("    sendWarning(message: string): void;")
            appendLine("    sendInfo(message: string): void;")
            appendLine("    sendRaw(json: string): void;")
            appendLine("    raycast(maxDistance?: number, includeFluid?: boolean): RaycastResult | null;")
            appendLine()
            appendLine("    // Deprecated methods (kept for backward compatibility)")
            appendLine("    /** @deprecated Use Caller.player != null instead */")
            appendLine("    isPlayer(): boolean;")
            appendLine("    /** @deprecated Use Caller.position.dimension instead */")
            appendLine("    getDimension(): string;")
            appendLine("    /** @deprecated Use Caller.name instead */")
            appendLine("    getName(): string;")
            appendLine("    /** @deprecated Use Caller.position instead */")
            appendLine("    getPosition(): { x: number; y: number; z: number; dimension: string };")
            appendLine("    /** @deprecated Use Caller.rotation instead */")
            appendLine("    getRotation(): { yaw: number; pitch: number } | null;")
            appendLine("};")
            appendLine()

            appendLine("declare const Args: string[];")
            appendLine()
        }

        Files.writeString(file, content)
    }

    /**
     * Load static NBT structure type definitions from resources.
     * These are hand-crafted, version-specific definitions for Minecraft 1.21.1.
     */
    private fun loadStaticNBTStructureTypes(): String {
        return try {
            val resourceStream = TypeGenerator::class.java.getResourceAsStream("/rhettjs-types/nbt-structure.d.ts")
            if (resourceStream != null) {
                resourceStream.bufferedReader().use { it.readText() }
            } else {
                // Fallback if resource not found
                println("Warning: Could not load static NBT structure types from resources")
                "// NBT structure types not available"
            }
        } catch (e: Exception) {
            println("Warning: Failed to load static NBT structure types: ${e.message}")
            "// NBT structure types not available"
        }
    }













    /**
     * Dynamically generate TypeScript definition for a specific API using reflection.
     */
    private fun generateApiDefinition(name: String): String? {
        return try {
            when (name) {
                "console" -> {
                    // Inspect ConsoleAPI
                    val consoleApi = ConsoleAPI()
                    val methods = ReflectionIntrospector.introspectJavaObject(consoleApi)
                    // Add @ts-ignore to avoid conflict with built-in console type
                    "// @ts-ignore\n" + ReflectionIntrospector.generateInterfaceDefinition("console", methods)
                }
                "logger" -> {
                    // Inspect LoggerAPI
                    val loggerApi = LoggerAPI()
                    val methods = ReflectionIntrospector.introspectJavaObject(loggerApi)
                    ReflectionIntrospector.generateInterfaceDefinition("logger", methods)
                }
                "task" -> {
                    // TaskAPI - returns Promise
                    buildString {
                        appendLine("/**")
                        appendLine(" * Execute a function on a worker thread.")
                        appendLine(" * Returns a Promise that resolves when the worker completes.")
                        appendLine(" *")
                        appendLine(" * Workers run in isolated Context but CAN access parent scope via closures.")
                        appendLine(" * ⚠️ AVOID sharing mutable state - workers run concurrently, causing race conditions!")
                        appendLine(" * ")
                        appendLine(" * Workers CAN use: console, logger, Structure, task() (nested), Runtime")
                        appendLine(" * Workers CANNOT use: wait(), player, world, server APIs")
                        appendLine(" *")
                        appendLine(" * @param callback Function to execute on worker thread")
                        appendLine(" * @param args Arguments to pass to the callback (must be primitives or JS objects)")
                        appendLine(" * @returns Promise that resolves with the callback's return value")
                        appendLine(" *")
                        appendLine(" * @example Pass data as arguments (recommended)")
                        appendLine(" * const data = [1, 2, 3];")
                        appendLine(" * task((arr) => arr.map(x => x * 2), data).then(result => {")
                        appendLine(" *     console.log(result); // [2, 4, 6]")
                        appendLine(" * });")
                        appendLine(" *")
                        appendLine(" * @example Using closures (works, but avoid mutable state)")
                        appendLine(" * const MULTIPLIER = 10;")
                        appendLine(" * task((val) => val * MULTIPLIER, 5).then(console.log); // 50")
                        appendLine(" *")
                        appendLine(" * @example ⚠️ AVOID - Race condition with shared mutable state")
                        appendLine(" * const arr = [];")
                        appendLine(" * task(() => arr.push(1));  // DON'T DO THIS - concurrent modification!")
                        appendLine(" *")
                        appendLine(" * @example Nested tasks (automatically runs immediately on same thread)")
                        appendLine(" * task(() => {")
                        appendLine(" *     return task(() => \"inner\"); // Runs immediately, returns resolved Promise")
                        appendLine(" * }).then(result => console.log(result)); // \"inner\"")
                        appendLine(" */")
                        appendLine("declare function task<T = any>(")
                        appendLine("    callback: (...args: any[]) => T,")
                        appendLine("    ...args: any[]")
                        appendLine("): Promise<T>;")
                        appendLine()
                        appendLine("/**")
                        appendLine(" * Wait for a specified number of game ticks before resolving.")
                        appendLine(" * Returns a Promise that resolves after N ticks (20 ticks = 1 second).")
                        appendLine(" *")
                        appendLine(" * ONLY works on the server thread (NOT in workers).")
                        appendLine(" * Workers should exit and use .thenWait() to return to server thread.")
                        appendLine(" *")
                        appendLine(" * @param ticks Number of game ticks to wait (minimum 1)")
                        appendLine(" * @returns Promise that resolves with undefined after the delay")
                        appendLine(" *")
                        appendLine(" * @example Basic wait")
                        appendLine(" * wait(20).then(() => {")
                        appendLine(" *     console.log(\"1 second later\");")
                        appendLine(" * });")
                        appendLine(" *")
                        appendLine(" * @example Sequential waits")
                        appendLine(" * wait(10).then(() => {")
                        appendLine(" *     console.log(\"After 10 ticks\");")
                        appendLine(" *     return wait(10);")
                        appendLine(" * }).then(() => {")
                        appendLine(" *     console.log(\"After 20 ticks total\");")
                        appendLine(" * });")
                        appendLine(" *")
                        appendLine(" * @example Combining with task")
                        appendLine(" * task(() => Structure.read(\"house\"))")
                        appendLine(" *     .thenWait(20) // Wait 1 second after reading")
                        appendLine(" *     .then(data => console.log(\"Delayed result:\", data));")
                        appendLine(" */")
                        appendLine("declare function wait(ticks: number): Promise<void>;")
                        appendLine()
                        appendLine("/**")
                        appendLine(" * Promise extensions for chaining async operations.")
                        appendLine(" * Added by RhettJS to Promise.prototype.")
                        appendLine(" */")
                        appendLine("interface Promise<T> {")
                        appendLine("    /**")
                        appendLine("     * Chain to a worker thread.")
                        appendLine("     * If the Promise resolves with a value, it's passed to the callback.")
                        appendLine("     * If the Promise resolves with undefined, the callback is called with no arguments.")
                        appendLine("     *")
                        appendLine("     * @param callback Function to execute on worker thread")
                        appendLine("     * @returns Promise that resolves with the worker's return value")
                        appendLine("     *")
                        appendLine("     * @example With value")
                        appendLine("     * task(() => \"step1\")")
                        appendLine("     *     .thenTask(result => result + \"-step2\")")
                        appendLine("     *     .then(result => console.log(result)); // \"step1-step2\"")
                        appendLine("     *")
                        appendLine("     * @example With undefined (no argument)")
                        appendLine("     * Promise.resolve()")
                        appendLine("     *     .thenTask(() => \"from-worker\")")
                        appendLine("     *     .then(result => console.log(result)); // \"from-worker\"")
                        appendLine("     */")
                        appendLine("    thenTask<U>(callback: (value: T) => U): Promise<U>;")
                        appendLine()
                        appendLine("    /**")
                        appendLine("     * Chain with a tick delay, passing the result through.")
                        appendLine("     * Equivalent to: .then(result => wait(ticks).then(() => result))")
                        appendLine("     *")
                        appendLine("     * @param ticks Number of game ticks to wait")
                        appendLine("     * @returns Promise that resolves with the same value after the delay")
                        appendLine("     *")
                        appendLine("     * @example")
                        appendLine("     * task(() => 42)")
                        appendLine("     *     .thenWait(20) // Wait 1 second")
                        appendLine("     *     .then(result => console.log(result)); // 42 (preserved)")
                        appendLine("     */")
                        appendLine("    thenWait(ticks: number): Promise<T>;")
                        append("}")
                    }
                }
                "wait" -> null  // wait() is generated together with task()
                "schedule" -> null  // schedule() is deprecated/removed
                else -> null
            }
        } catch (e: Exception) {
            println("Warning: Failed to generate definition for $name: ${e.message}")
            null
        }
    }

    /**
     * Generate Structure API definition dynamically via reflection.
     * Introspects the actual StructureAPI and NBTAPI classes to generate method signatures.
     */
    private fun generateStructureApiDefinition(): String? {
        return try {
            // Verify Structure API is initialized
            val structureWrapper = ScriptEngine.structureAPI ?: return null

            // Access the underlying StructureAPI via reflection
            val structureApiField = structureWrapper.javaClass.getDeclaredField("structureApi")
            structureApiField.isAccessible = true
            val structureApi = structureApiField.get(structureWrapper) as StructureAPI

            // Get NBTAPI instance
            val nbtApi = structureApi.getNbtApi()

            // Introspect StructureAPI methods
            val structureMethods = ReflectionIntrospector.introspectJavaObject(structureApi)
                .filter { it.name in setOf("list", "read", "write") }

            // Introspect NBTAPI methods
            val nbtMethods = ReflectionIntrospector.introspectJavaObject(nbtApi)
                .filter { it.name in setOf("forEach", "filter", "find", "some") }

            buildString {
                // Generate supporting interfaces

                // NBTFilterResult is a real Kotlin data class - introspect it
                val filterResultClass = NBTAPI.FilterResult::class.java
                val filterResultProperties = filterResultClass.declaredFields
                    .filter { !it.isSynthetic && !java.lang.reflect.Modifier.isStatic(it.modifiers) }
                    .map { field ->
                        val fieldName = field.name
                        val fieldType = when (fieldName) {
                            "path" -> "(string | number)[]"  // Better type for path
                            else -> TypeMapper.toTypeScript(field.genericType)
                        }
                        ReflectionIntrospector.PropertySignature(fieldName, fieldType, readonly = true)
                    }

                appendLine("interface NBTFilterResult {")
                filterResultProperties.forEach { prop ->
                    appendLine("    ${prop.name}: ${prop.type};")
                }
                appendLine("}")
                appendLine()

                // Include static NBT structure type definitions from resources
                // These are version-specific (Minecraft 1.21.1) and hand-crafted for accuracy
                val nbtStructureTypes = loadStaticNBTStructureTypes()
                appendLine(nbtStructureTypes)
                appendLine()

                // Generate main Structure interface using introspected methods
                appendLine("declare const Structure: {")

                // Add introspected methods with better parameter names
                structureMethods.forEach { method ->
                    // Use better parameter names for known methods
                    val signature = when (method.name) {
                        "list" -> "pool?: string"
                        "read" -> "name: string"
                        "write" -> "name: string, data: StructureData"
                        else -> method.parameters.joinToString(", ") { param ->
                            val paramName = param.name
                            val optional = if (param.optional) "?" else ""
                            if (paramName.startsWith("...")) {
                                "$paramName: ${param.type}"
                            } else {
                                "$paramName$optional: ${param.type}"
                            }
                        }
                    }

                    // Override return type for known methods with better types
                    val returnType = when (method.name) {
                        "list" -> "string[]"
                        "read" -> "StructureData | null"
                        "write" -> "void"
                        else -> method.returnType
                    }

                    appendLine("    ${method.name}($signature): $returnType;")
                }

                // Generate nested nbt object with better callback signatures
                appendLine("    nbt: {")
                nbtMethods.forEach { method ->
                    // Use better signatures for known NBT methods
                    val signature = when (method.name) {
                        "forEach" -> "data: any, callback: (value: any, path: (string | number)[], parent: any) => void"
                        "filter" -> "data: any, predicate: (value: any, path: (string | number)[], parent: any) => boolean"
                        "find" -> "data: any, predicate: (value: any, path: (string | number)[], parent: any) => boolean"
                        "some" -> "data: any, predicate: (value: any, path: (string | number)[], parent: any) => boolean"
                        else -> method.parameters.joinToString(", ") { param ->
                            val paramName = param.name
                            val optional = if (param.optional) "?" else ""
                            if (paramName.startsWith("...")) {
                                "$paramName: ${param.type}"
                            } else {
                                "$paramName$optional: ${param.type}"
                            }
                        }
                    }

                    // Override return type for known methods with better types
                    val returnType = when (method.name) {
                        "forEach" -> "void"
                        "filter" -> "NBTFilterResult[]"
                        "find" -> "NBTFilterResult | null"
                        "some" -> "boolean"
                        else -> method.returnType
                    }

                    appendLine("        ${method.name}($signature): $returnType;")
                }
                appendLine("    };")
                appendLine("};")
            }
        } catch (e: Exception) {
            println("Warning: Failed to generate Structure API definition: ${e.message}")
            e.printStackTrace()
            null
        }
    }



    /**
     * Generate Store API definition with namespace support.
     */
    private fun generateStoreApiDefinition(): String? {
        return try {
            buildString {
                appendLine("/**")
                appendLine(" * Namespaced store for organizing related data.")
                appendLine(" * Provides scoped key-value operations within a namespace.")
                appendLine(" */")
                appendLine("interface NamespacedStore {")
                appendLine("    /** Store a value under a key in this namespace */")
                appendLine("    set(key: string, value: any): void;")
                appendLine("    /** Retrieve a value by key from this namespace */")
                appendLine("    get(key: string): any;")
                appendLine("    /** Check if a key exists in this namespace */")
                appendLine("    has(key: string): boolean;")
                appendLine("    /** Delete a key from this namespace */")
                appendLine("    delete(key: string): boolean;")
                appendLine("    /** Clear all keys in this namespace only */")
                appendLine("    clear(): void;")
                appendLine("    /** Get all keys in this namespace */")
                appendLine("    keys(): string[];")
                appendLine("    /** Get the number of items in this namespace */")
                appendLine("    size(): number;")
                appendLine("    /** Get all entries in this namespace as a map */")
                appendLine("    entries(): Record<string, any>;")
                appendLine("}")
                appendLine()
                appendLine("/**")
                appendLine(" * Ephemeral key-value store for sharing data across script executions.")
                appendLine(" * Data persists in memory until server restart.")
                appendLine(" *")
                appendLine(" * @example")
                appendLine(" * const positions = Store.namespace('positions');")
                appendLine(" * positions.set('player1:pos1', { x: 100, y: 64, z: 200 });")
                appendLine(" * const pos = positions.get('player1:pos1');")
                appendLine(" */")
                appendLine("declare const Store: {")
                appendLine("    /** Create a namespaced store for organizing related data */")
                appendLine("    namespace(namespace: string): NamespacedStore;")
                appendLine("    /** Get all namespaces currently in use */")
                appendLine("    namespaces(): string[];")
                appendLine("    /** Clear all data across all namespaces */")
                appendLine("    clearAll(): void;")
                appendLine("    /** Get total number of items across all namespaces */")
                appendLine("    size(): number;")
                append("};")
            }
        } catch (e: Exception) {
            println("Warning: Failed to generate Store API definition: ${e.message}")
            null
        }
    }

    /**
     * Generate World API definition dynamically via reflection.
     */
    private fun generateWorldApiDefinition(): String? {
        return try {
            val worldApi = ScriptEngine.worldAPI ?: return null

            // Access the underlying WorldAPI via reflection
            val worldApiField = worldApi.javaClass.getDeclaredField("worldApi")
            worldApiField.isAccessible = true
            val actualWorldApi = worldApiField.get(worldApi) as com.rhett.rhettjs.api.WorldAPI

            // Introspect methods (synthetic methods already filtered by ReflectionIntrospector)
            val methods = ReflectionIntrospector.introspectJavaObject(actualWorldApi)

            // Manual parameter names for better DX (reflection doesn't preserve names)
            val parameterOverrides = mapOf(
                "grab" to listOf("world", "x1", "y1", "z1", "x2", "y2", "z2"),
                "grabToFile" to listOf("world", "x1", "y1", "z1", "x2", "y2", "z2", "filename", "subdirectory?"),
                "grabLarge" to listOf("world", "x1", "y1", "z1", "x2", "y2", "z2", "name", "pieceSize?", "namespace?"),
                "placeLarge" to listOf("world", "x", "y", "z", "namespace", "name", "rotation?"),
                "listLarge" to listOf("namespace?"),
                "getLargeMetadata" to listOf("namespace", "name"),
                "blocksListLarge" to listOf("namespace", "name"),
                "blocksReplaceLarge" to listOf("namespace", "name", "replacementMap"),
                "blocksReplaceLargeVanilla" to listOf("namespace", "name", "typeOverrides?")
            )

            // Better return types
            val returnTypeOverrides = mapOf(
                "grab" to "Record<string, any> | null",
                "grabToFile" to "string",
                "grabLarge" to "{ name: string; namespace: string; pieces: number; requires: string[]; path: string }",
                "listLarge" to "Array<{ namespace: string; name: string; location: string }>",
                "placeLarge" to "{ piecesPlaced: number; blocksPlaced: number; metadata: any; rotation: number; position: any }",
                "getLargeMetadata" to "{ requires: string[]; pieceSize: any; gridSize: any; totalSize: any; pieceCount: number; location: string } | null",
                "blocksListLarge" to "Record<string, number>",
                "blocksReplaceLarge" to "number",
                "blocksReplaceLargeVanilla" to "{ piecesModified: number; warnings: string[] }"
            )

            buildString {
                appendLine("declare const World: {")

                methods.forEach { method ->
                    // Use manual parameter names if available
                    val params = if (parameterOverrides.containsKey(method.name)) {
                        parameterOverrides[method.name]!!.joinToString(", ") { paramSpec ->
                            if (paramSpec.endsWith("?")) {
                                val paramName = paramSpec.removeSuffix("?")
                                // Infer type based on method
                                val paramType = when {
                                    paramName.startsWith("x") || paramName.startsWith("y") || paramName.startsWith("z")
                                        || paramName.endsWith("1") || paramName.endsWith("2") -> "number"
                                    paramName == "rotation" -> "number"
                                    paramName == "pieceSize" -> "number[]"
                                    paramName.endsWith("Map") -> "Record<string, string>"
                                    paramName.endsWith("Overrides") -> "Record<string, string>"
                                    else -> "string"
                                }
                                "$paramName?: $paramType"
                            } else {
                                // Required parameter
                                val paramType = when {
                                    paramSpec.startsWith("x") || paramSpec.startsWith("y") || paramSpec.startsWith("z")
                                        || paramSpec.endsWith("1") || paramSpec.endsWith("2") -> "number"
                                    paramSpec == "rotation" -> "number"
                                    paramSpec == "pieceSize" -> "number[]"
                                    paramSpec.endsWith("Map") -> "Record<string, string>"
                                    paramSpec.endsWith("Overrides") -> "Record<string, string>"
                                    else -> "string"
                                }
                                "$paramSpec: $paramType"
                            }
                        }
                    } else {
                        // Fall back to reflection
                        method.parameters.joinToString(", ") { param ->
                            val optional = if (param.optional) "?" else ""
                            "${param.name}$optional: ${param.type}"
                        }
                    }

                    // Use manual return type if available
                    val returnType = returnTypeOverrides[method.name] ?: method.returnType

                    appendLine("    ${method.name}($params): $returnType;")
                }

                append("};")
            }
        } catch (e: Exception) {
            println("Warning: Failed to generate World API definition: ${e.message}")
            e.printStackTrace()
            null
        }
    }

    /**
     * Generate Command API definition dynamically via reflection.
     * Command API returns Promises (CompletableFuture in Java).
     */
    private fun generateCommandApiDefinition(): String? {
        return try {
            // Command API is injected dynamically, so we create a dummy instance to introspect
            val dummyServer = null as? net.minecraft.server.MinecraftServer
            if (dummyServer == null) {
                // Can't create instance without server, use manual definition
                return buildString {
                    appendLine("/** Command execution result */")
                    appendLine("interface CommandResult {")
                    appendLine("    success: boolean;")
                    appendLine("    resultCount: number;")
                    appendLine("    feedback: string[];")
                    appendLine("    error: string | null;")
                    appendLine("}")
                    appendLine()
                    appendLine("/** Command execution API (available in command contexts and /rjs run) */")
                    appendLine("declare const Command: {")
                    appendLine("    /** Execute command as the caller (player). Returns Promise. */")
                    appendLine("    execute(command: string): Promise<CommandResult>;")
                    appendLine("    /** Execute command at specific position. Returns Promise. */")
                    appendLine("    executeAt(x: number, y: number, z: number, command: string): Promise<CommandResult>;")
                    appendLine("    /** Execute command as server/console. Returns Promise. */")
                    appendLine("    executeAsServer(command: string): Promise<CommandResult>;")
                    appendLine("    /** Get command suggestions for partial command. Returns Promise. */")
                    appendLine("    suggest(partialCommand: string): Promise<string[]>;")
                    append("};")
                }
            }

            null
        } catch (e: Exception) {
            println("Warning: Failed to generate Command API definition: ${e.message}")
            null
        }
    }

    /**
     * Generate Event API definition dynamically via reflection.
     * Handles ServerEvents and StartupEvents.
     */
    private fun generateEventApiDefinition(apiName: String): String? {
        return try {
            when (apiName) {
                "ServerEvents" -> {
                    val serverEventsApi = com.rhett.rhettjs.events.ServerEventsAPI
                    val methods = ReflectionIntrospector.introspectJavaObject(serverEventsApi)
                        .filter { it.name in setOf(
                            "itemUse", "basicCommand", "command",
                            "blockRightClicked", "blockLeftClicked", "blockPlaced", "blockBroken"
                        )}

                    buildString {
                        appendLine("/** Block event data passed to block event handlers */")
                        appendLine("interface BlockEvent {")
                        appendLine("    position: { x: number; y: number; z: number; dimension: string };")
                        appendLine("    block: { id: string; properties: Record<string, string> };")
                        appendLine("    player?: any;  // ServerPlayer object (use Runtime.inspect() to explore)")
                        appendLine("    playerData?: { name: string; uuid: string; isCreative: boolean };")
                        appendLine("    isRightClick?: boolean;")
                        appendLine("    item?: { id: string; count: number; displayName?: string; nbt?: Record<string, any> };")
                        appendLine("    face?: string;")
                        appendLine("    placedAgainst?: { x: number; y: number; z: number };")
                        appendLine("    experience?: number;")
                        appendLine("    drops?: Array<{ id: string; count: number }>;")
                        appendLine()
                        appendLine("    // Messaging methods (same as Caller API, compatible with MessageBuffer)")
                        appendLine("    sendMessage(message: string): void;")
                        appendLine("    sendSuccess(message: string): void;")
                        appendLine("    sendError(message: string): void;")
                        appendLine("    sendWarning(message: string): void;")
                        appendLine("    sendInfo(message: string): void;")
                        appendLine("    sendRaw(json: string): void;")
                        appendLine("    isPlayer(): boolean;")
                        appendLine()
                        appendLine("    // Event cancellation")
                        appendLine("    /** Cancel this event to prevent default behavior (e.g., block break) */")
                        appendLine("    cancel(): void;")
                        appendLine("    /** Whether this event has been cancelled */")
                        appendLine("    cancelled: boolean;")
                        appendLine("}")
                        appendLine()
                        appendLine("/** Command execution context (consistent with Caller and event APIs) */")
                        appendLine("interface CommandContext {")
                        appendLine("    /** The player who executed the command (null if console/command block) */")
                        appendLine("    player?: any;  // ServerPlayer object")
                        appendLine("    /** The command source (CommandSourceStack) */")
                        appendLine("    source: any;")
                        appendLine("    /** Get the player's name or 'Server' if not a player */")
                        appendLine("    playerName: string;")
                        appendLine("    /** Unwrap to get the raw Brigadier CommandContext */")
                        appendLine("    unwrap(): any;")
                        appendLine()
                        appendLine("    // Messaging methods (consistent with Caller and event APIs)")
                        appendLine("    /** Send a success message (green) */")
                        appendLine("    sendSuccess(message: string): void;")
                        appendLine("    /** Send an error message (red) */")
                        appendLine("    sendError(message: string): void;")
                        appendLine("    /** Send a normal message */")
                        appendLine("    sendMessage(message: string): void;")
                        appendLine("}")
                        appendLine()
                        appendLine("/** Command builder for creating typed commands */")
                        appendLine("interface CommandBuilder {")
                        appendLine("    types: any; // ArgumentTypeWrappers")
                        appendLine("    addArgument(name: string, type: any): void;")
                        appendLine("    setExecutor(handler: (context: CommandContext) => number): void;")
                        appendLine("    requiresPermission(level: number): void;")
                        appendLine("}")
                        appendLine()
                        appendLine("/** Runtime event handlers (available in server/ and scripts/) */")
                        appendLine("declare const ServerEvents: {")
                        appendLine("    /** Register handler for item use events */")
                        appendLine("    itemUse(handler: (event: any) => void): void;")
                        appendLine("    /** Register basic command with string arguments */")
                        appendLine("    basicCommand(commandName: string, handler: (args: string) => void): void;")
                        appendLine("    /** Register full Brigadier command with typed arguments */")
                        appendLine("    command(commandName: string, builderFunction: (cmd: CommandBuilder) => void): void;")
                        appendLine("    /** Register handler for block right-click events */")
                        appendLine("    blockRightClicked(handler: (event: BlockEvent) => void): void;")
                        appendLine("    blockRightClicked(blockFilter: string, handler: (event: BlockEvent) => void): void;")
                        appendLine("    /** Register handler for block left-click events */")
                        appendLine("    blockLeftClicked(handler: (event: BlockEvent) => void): void;")
                        appendLine("    blockLeftClicked(blockFilter: string, handler: (event: BlockEvent) => void): void;")
                        appendLine("    /** Register handler for block placement events */")
                        appendLine("    blockPlaced(handler: (event: BlockEvent) => void): void;")
                        appendLine("    blockPlaced(blockFilter: string, handler: (event: BlockEvent) => void): void;")
                        appendLine("    /** Register handler for block breaking events */")
                        appendLine("    blockBroken(handler: (event: BlockEvent) => void): void;")
                        appendLine("    blockBroken(blockFilter: string, handler: (event: BlockEvent) => void): void;")
                        append("};")
                    }
                }
                "StartupEvents" -> {
                    val startupEventsApi = com.rhett.rhettjs.events.StartupEventsAPI
                    val methods = ReflectionIntrospector.introspectJavaObject(startupEventsApi)
                        .filter { it.name == "registry" }

                    buildString {
                        appendLine("/** Startup event handlers (available in startup/ only) */")
                        appendLine("declare const StartupEvents: {")
                        appendLine("    /** Register handler for registry events (item, block) */")
                        appendLine("    registry(type: 'item' | 'block', handler: (event: any) => void): void;")
                        append("};")
                    }
                }
                else -> null
            }
        } catch (e: Exception) {
            println("Warning: Failed to generate Event API definition for $apiName: ${e.message}")
            e.printStackTrace()
            null
        }
    }

    /**
     * Generate README with IDE setup instructions.
     */
    private fun generateReadme(file: Path, hasGlobals: Boolean) {
        val content = buildString {
            appendLine("# RhettJS TypeScript Definitions")
            appendLine()
            appendLine("Auto-generated type definitions for IDE autocomplete.")
            appendLine()
            appendLine("**Generated**: ${LocalDateTime.now()}")
            appendLine()
            appendLine("## Files")
            appendLine()
            appendLine("- `rhettjs.d.ts` - Core RhettJS APIs (console, logger, task, schedule, Structure, Caller, Args)")
            appendLine("- `jsconfig.json.template` - VSCode project configuration template")
            appendLine()
            appendLine("## IDE Setup")
            appendLine()
            appendLine("### Visual Studio Code")
            appendLine()
            appendLine("**Option 1: Project-Wide (Recommended)**")
            appendLine()
            appendLine("1. Copy the template:")
            appendLine("   ```bash")
            appendLine("   cp rjs/__types/jsconfig.json.template rjs/jsconfig.json")
            appendLine("   ```")
            appendLine("2. Reload VSCode (Cmd/Ctrl + Shift + P → \"Reload Window\")")
            appendLine("3. All scripts now have autocomplete!")
            appendLine()
            appendLine("**Option 2: Per-File**")
            appendLine()
            appendLine("Add to the top of your script:")
            appendLine("```javascript")
            appendLine("/// <reference path=\"../__types/rhettjs.d.ts\" />")
            if (hasGlobals) {
                appendLine("/// <reference path=\"../__types/rhettjs-globals.d.ts\" />")
            }
            appendLine("```")
            appendLine()
            appendLine("### IntelliJ IDEA / WebStorm")
            appendLine()
            appendLine("**Automatic** - Should work out of the box!")
            appendLine()
            appendLine("If not:")
            appendLine("1. Right-click `rjs/__types/` folder")
            appendLine("2. Mark Directory As → **Resource Root**")
            appendLine("3. File → Invalidate Caches → Restart (if needed)")
            appendLine()
            appendLine("### Other IDEs")
            appendLine()
            appendLine("Most IDEs with TypeScript/JavaScript support will auto-discover `.d.ts` files.")
            appendLine("If not, add reference directives (see VSCode Option 2 above).")
            appendLine()
            appendLine("## Testing Autocomplete")
            appendLine()
            appendLine("Create a test script and type:")
            appendLine()
            appendLine("```javascript")
            appendLine("console.    // Should show: log, info, warn, error")
            appendLine("Structure.  // Should show: read, write, list")
            appendLine("```")
            appendLine()
            if (hasGlobals) {
                appendLine("For custom globals:")
                appendLine("```javascript")
                appendLine("new MessageBuffer()  // Should show constructor and methods")
                appendLine("```")
                appendLine()
            }
            appendLine("If you see suggestions, autocomplete is working! 🎉")
            appendLine()
            appendLine("## Notes")
            appendLine()
            appendLine("- **Core APIs** are dynamically introspected and accurate")
            appendLine("- **Structure/NBT types** match the official Minecraft NBT structure format")
            appendLine("- **Custom globals** are introspected at runtime - complex patterns may need manual refinement")
            appendLine("- **Re-generate** by running `/rjs probe` in-game")
            appendLine("- **Manually edit** `rhettjs-globals.d.ts` if auto-generated types aren't perfect")
            appendLine()
            appendLine("## Examples")
            appendLine()
            appendLine("See example scripts at:")
            appendLine("- `docs/example-scripts/` (in repository)")
            appendLine("- GitHub: https://github.com/your-org/RhettJS/tree/main/docs/example-scripts")
            appendLine()
            appendLine("## More Information")
            appendLine()
            appendLine("- RhettJS Documentation: `docs/`")
            appendLine("- API Reference: `docs/api/`")
            appendLine("- GitHub: https://github.com/your-org/RhettJS")
        }

        Files.writeString(file, content)
    }

    /**
     * Generate jsconfig.json.template for VSCode.
     */
    private fun generateJsConfigTemplate(file: Path) {
        val content = """{
  "compilerOptions": {
    "target": "ES5",
    "module": "commonjs",
    "checkJs": false,
    "allowJs": true,
    "noEmit": true,
    "moduleResolution": "node"
  },
  "include": [
    "scripts/**/*.js",
    "server/**/*.js",
    "startup/**/*.js",
    "globals/**/*.js"
  ],
  "exclude": [
    "node_modules"
  ]
}
"""
        Files.writeString(file, content)
    }

    /**
     * Result of type generation.
     */
    sealed class GenerationResult {
        data class Success(
            val filesGenerated: Int,
            val coreApiCount: Int,
            val globalsCount: Int
        ) : GenerationResult()

        data class Error(
            val message: String,
            val exception: Exception
        ) : GenerationResult()
    }

}

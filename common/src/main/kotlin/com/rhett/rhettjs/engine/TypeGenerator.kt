package com.rhett.rhettjs.engine

import com.rhett.rhettjs.api.*
import java.nio.file.Files
import java.nio.file.Path
import java.time.LocalDateTime

/**
 * TypeScript definition generator for RhettJS APIs.
 * Designed to run in-game via /rjs probe with full runtime context.
 *
 * Generates accurate TypeScript definitions by introspecting:
 * - Core APIs (console, logger, task, schedule) via reflection
 * - Structure API and NBT utilities via reflection
 * - JavaScript globals from globals/ directory via Rhino introspection
 * - Event APIs
 */
object TypeGenerator {

    /**
     * Generate TypeScript definitions for RhettJS APIs.
     * Must be called from within the game runtime (via /rjs probe).
     *
     * @param outputDir Directory to write the generated files (e.g., rjs/__types/)
     * @param scriptsDir Scripts directory containing globals/ subdirectory
     * @param category Script category to introspect (default: UTILITY for full API surface)
     * @return GenerationResult with status and file count
     */
    fun generate(
        outputDir: Path,
        scriptsDir: Path,
        category: ScriptCategory = ScriptCategory.UTILITY
    ): GenerationResult {
        return try {
            // Create output directory if it doesn't exist
            if (!Files.exists(outputDir)) {
                Files.createDirectories(outputDir)
            }

            // Introspect APIs from runtime
            val baseApis = ScriptEngine.introspectAvailableApis(category)

            // Categorize APIs
            val coreApis = baseApis.filter { (name, _) ->
                name in listOf("console", "logger", "task", "schedule")
            }

            val constants = baseApis.filter { (name, _) ->
                name in listOf("MAX_WORKER_THREADS", "TICKS_PER_SECOND", "IS_DEBUG")
            }

            val structureApi = baseApis.filter { (name, _) -> name == "Structure" }
            val eventApis = baseApis.filter { (name, _) -> name.endsWith("Events") }

            // Globals are everything else (excluding standard JS objects)
            val standardJsObjects = setOf(
                "Object", "Array", "String", "Number", "Boolean", "Date", "Math", "JSON",
                "RegExp", "Error", "Function", "undefined", "NaN", "Infinity",
                "parseInt", "parseFloat", "isNaN", "isFinite", "decodeURI", "decodeURIComponent",
                "encodeURI", "encodeURIComponent", "escape", "unescape", "eval"
            )

            val globals = baseApis.filter { (name, _) ->
                name !in coreApis.keys &&
                name !in constants.keys &&
                name !in structureApi.keys &&
                name !in eventApis.keys &&
                name !in standardJsObjects
            }

            // Generate files
            var filesGenerated = 0

            generateCoreTypes(outputDir.resolve("rhettjs.d.ts"), coreApis, structureApi, eventApis)
            filesGenerated++

            generateReadme(outputDir.resolve("README.md"), false)
            filesGenerated++

            generateJsConfigTemplate(outputDir.resolve("jsconfig.json.template"))
            filesGenerated++

            GenerationResult.Success(
                filesGenerated = filesGenerated,
                coreApiCount = coreApis.size + constants.size + structureApi.size + eventApis.size + 2, // +2 for Caller and Args
                globalsCount = 0
            )

        } catch (e: Exception) {
            GenerationResult.Error(e.message ?: "Unknown error", e)
        }
    }

    /**
     * Generate core TypeScript definitions file using reflection.
     */
    private fun generateCoreTypes(
        file: Path,
        coreApis: Map<String, String>,
        structureApi: Map<String, String>,
        eventApis: Map<String, String>
    ) {
        val content = buildString {
            appendLine("// RhettJS Core API Type Definitions")
            appendLine("// Auto-generated by TypeGenerator using Java Reflection")
            appendLine("// Last updated: ${LocalDateTime.now()}")
            appendLine()

            // Runtime API
            appendLine("// ============================================================================")
            appendLine("// Runtime API")
            appendLine("// ============================================================================")
            appendLine()
            appendLine("/** Runtime environment and lifecycle control */")
            appendLine("declare const Runtime: {")
            appendLine("    /** Environment constants */")
            appendLine("    env: {")
            appendLine("        /** Maximum number of worker threads available (determined at boot based on CPU cores, max 4) */")
            appendLine("        MAX_WORKER_THREADS: number;")
            appendLine("        /** Minecraft ticks per second (always 20) */")
            appendLine("        TICKS_PER_SECOND: number;")
            appendLine("        /** Whether debug logging is enabled in rhettjs.json config */")
            appendLine("        IS_DEBUG: boolean;")
            appendLine("        /** RhettJS version */")
            appendLine("        RJS_VERSION: string;")
            appendLine("    };")
            appendLine("    /** Stop script execution and cancel all pending scheduled tasks */")
            appendLine("    exit(): void;")
            appendLine()
            appendLine("    /**")
            appendLine("     * Set the event loop timeout for the current script execution.")
            appendLine("     * Must be called before any async operations (task/wait).")
            appendLine("     * Default: 60000ms (60 seconds)")
            appendLine("     *")
            appendLine("     * WARNING: Setting this too high can cause server hangs if scripts don't complete.")
            appendLine("     * Use with caution.")
            appendLine("     *")
            appendLine("     * @param timeoutMs Maximum time to wait for async operations in milliseconds")
            appendLine("     *")
            appendLine("     * @example")
            appendLine("     * Runtime.setEventLoopTimeout(120000); // 2 minute timeout for slow data migration")
            appendLine("     */")
            appendLine("    setEventLoopTimeout(timeoutMs: number): void;")
            appendLine("};")
            appendLine()

            // Core APIs - dynamically generated via reflection
            if (coreApis.isNotEmpty()) {
                appendLine("// ============================================================================")
                appendLine("// Core APIs")
                appendLine("// ============================================================================")
                appendLine()

                coreApis.forEach { (name, _) ->
                    val apiDefinition = generateApiDefinition(name)
                    if (apiDefinition != null) {
                        appendLine(apiDefinition)
                        appendLine()
                    }
                }
            }

            // Structure API - dynamically generated via reflection
            if (structureApi.isNotEmpty()) {
                appendLine("// ============================================================================")
                appendLine("// Structure API")
                appendLine("// ============================================================================")
                appendLine()

                val structureDefinition = generateStructureApiDefinition()
                if (structureDefinition != null) {
                    appendLine(structureDefinition)
                    appendLine()
                }
            }

            // Event APIs
            if (eventApis.isNotEmpty()) {
                appendLine("// ============================================================================")
                appendLine("// Event APIs")
                appendLine("// ============================================================================")
                appendLine()
                eventApis.forEach { (name, _) ->
                    appendLine("declare const $name: any;  // TODO: Add detailed type definitions")
                    appendLine()
                }
            }

            // Utility Script Context APIs
            appendLine("// ============================================================================")
            appendLine("// Utility Script APIs (available in /rjs run)")
            appendLine("// ============================================================================")
            appendLine()

            // Generate Caller API dynamically by introspecting the class
            val callerMethods = CallerAPI::class.java.declaredMethods
                .filter { !it.isSynthetic && java.lang.reflect.Modifier.isPublic(it.modifiers) }
                .map { method ->
                    val params = method.parameters.mapIndexed { index, param ->
                        val paramName = "arg$index"  // Java reflection doesn't preserve param names
                        val paramType = TypeMapper.toTypeScript(param.parameterizedType)
                        ReflectionIntrospector.Parameter(paramName, paramType, optional = false)
                    }
                    val returnType = TypeMapper.toTypeScript(method.genericReturnType)

                    // Override parameter names for better DX
                    val betterParams: List<ReflectionIntrospector.Parameter> = when (method.name) {
                        "sendMessage", "sendSuccess", "sendError", "sendWarning", "sendInfo" ->
                            listOf(ReflectionIntrospector.Parameter("message", "string", false))
                        "sendRaw" ->
                            listOf(ReflectionIntrospector.Parameter("json", "string", false))
                        else -> params
                    }

                    ReflectionIntrospector.MethodSignature(method.name, betterParams, returnType)
                }
                .distinctBy { it.name }  // Remove overloads

            appendLine("declare const Caller: {")
            callerMethods.forEach { method ->
                val params = method.parameters.joinToString(", ") { param ->
                    val optional = if (param.optional) "?" else ""
                    "${param.name}$optional: ${param.type}"
                }
                appendLine("    ${method.name}($params): ${method.returnType};")
            }
            appendLine("};")
            appendLine()

            appendLine("declare const Args: string[];")
            appendLine()
        }

        Files.writeString(file, content)
    }

    /**
     * Load static NBT structure type definitions from resources.
     * These are hand-crafted, version-specific definitions for Minecraft 1.21.1.
     */
    private fun loadStaticNBTStructureTypes(): String {
        return try {
            val resourceStream = TypeGenerator::class.java.getResourceAsStream("/rhettjs-types/nbt-structure.d.ts")
            if (resourceStream != null) {
                resourceStream.bufferedReader().use { it.readText() }
            } else {
                // Fallback if resource not found
                println("Warning: Could not load static NBT structure types from resources")
                "// NBT structure types not available"
            }
        } catch (e: Exception) {
            println("Warning: Failed to load static NBT structure types: ${e.message}")
            "// NBT structure types not available"
        }
    }













    /**
     * Dynamically generate TypeScript definition for a specific API using reflection.
     */
    private fun generateApiDefinition(name: String): String? {
        return try {
            when (name) {
                "console" -> {
                    // Inspect ConsoleAPI
                    val consoleApi = ConsoleAPI()
                    val methods = ReflectionIntrospector.introspectJavaObject(consoleApi)
                    // Add @ts-ignore to avoid conflict with built-in console type
                    "// @ts-ignore\n" + ReflectionIntrospector.generateInterfaceDefinition("console", methods)
                }
                "logger" -> {
                    // Inspect LoggerAPI
                    val loggerApi = LoggerAPI()
                    val methods = ReflectionIntrospector.introspectJavaObject(loggerApi)
                    ReflectionIntrospector.generateInterfaceDefinition("logger", methods)
                }
                "task" -> {
                    // TaskAPI - returns Promise
                    buildString {
                        appendLine("/**")
                        appendLine(" * Execute a function on a worker thread.")
                        appendLine(" * Returns a Promise that resolves when the worker completes.")
                        appendLine(" *")
                        appendLine(" * Workers run in isolated Context but CAN access parent scope via closures.")
                        appendLine(" * âš ï¸ AVOID sharing mutable state - workers run concurrently, causing race conditions!")
                        appendLine(" * ")
                        appendLine(" * Workers CAN use: console, logger, Structure, task() (nested), Runtime")
                        appendLine(" * Workers CANNOT use: wait(), player, world, server APIs")
                        appendLine(" *")
                        appendLine(" * @param callback Function to execute on worker thread")
                        appendLine(" * @param args Arguments to pass to the callback (must be primitives or JS objects)")
                        appendLine(" * @returns Promise that resolves with the callback's return value")
                        appendLine(" *")
                        appendLine(" * @example Pass data as arguments (recommended)")
                        appendLine(" * const data = [1, 2, 3];")
                        appendLine(" * task((arr) => arr.map(x => x * 2), data).then(result => {")
                        appendLine(" *     console.log(result); // [2, 4, 6]")
                        appendLine(" * });")
                        appendLine(" *")
                        appendLine(" * @example Using closures (works, but avoid mutable state)")
                        appendLine(" * const MULTIPLIER = 10;")
                        appendLine(" * task((val) => val * MULTIPLIER, 5).then(console.log); // 50")
                        appendLine(" *")
                        appendLine(" * @example âš ï¸ AVOID - Race condition with shared mutable state")
                        appendLine(" * const arr = [];")
                        appendLine(" * task(() => arr.push(1));  // DON'T DO THIS - concurrent modification!")
                        appendLine(" *")
                        appendLine(" * @example Nested tasks (automatically runs immediately on same thread)")
                        appendLine(" * task(() => {")
                        appendLine(" *     return task(() => \"inner\"); // Runs immediately, returns resolved Promise")
                        appendLine(" * }).then(result => console.log(result)); // \"inner\"")
                        appendLine(" */")
                        appendLine("declare function task<T = any>(")
                        appendLine("    callback: (...args: any[]) => T,")
                        appendLine("    ...args: any[]")
                        appendLine("): Promise<T>;")
                        appendLine()
                        appendLine("/**")
                        appendLine(" * Wait for a specified number of game ticks before resolving.")
                        appendLine(" * Returns a Promise that resolves after N ticks (20 ticks = 1 second).")
                        appendLine(" *")
                        appendLine(" * ONLY works on the server thread (NOT in workers).")
                        appendLine(" * Workers should exit and use .thenWait() to return to server thread.")
                        appendLine(" *")
                        appendLine(" * @param ticks Number of game ticks to wait (minimum 1)")
                        appendLine(" * @returns Promise that resolves with undefined after the delay")
                        appendLine(" *")
                        appendLine(" * @example Basic wait")
                        appendLine(" * wait(20).then(() => {")
                        appendLine(" *     console.log(\"1 second later\");")
                        appendLine(" * });")
                        appendLine(" *")
                        appendLine(" * @example Sequential waits")
                        appendLine(" * wait(10).then(() => {")
                        appendLine(" *     console.log(\"After 10 ticks\");")
                        appendLine(" *     return wait(10);")
                        appendLine(" * }).then(() => {")
                        appendLine(" *     console.log(\"After 20 ticks total\");")
                        appendLine(" * });")
                        appendLine(" *")
                        appendLine(" * @example Combining with task")
                        appendLine(" * task(() => Structure.read(\"house\"))")
                        appendLine(" *     .thenWait(20) // Wait 1 second after reading")
                        appendLine(" *     .then(data => console.log(\"Delayed result:\", data));")
                        appendLine(" */")
                        appendLine("declare function wait(ticks: number): Promise<void>;")
                        appendLine()
                        appendLine("/**")
                        appendLine(" * Promise extensions for chaining async operations.")
                        appendLine(" * Added by RhettJS to Promise.prototype.")
                        appendLine(" */")
                        appendLine("interface Promise<T> {")
                        appendLine("    /**")
                        appendLine("     * Chain to a worker thread.")
                        appendLine("     * If the Promise resolves with a value, it's passed to the callback.")
                        appendLine("     * If the Promise resolves with undefined, the callback is called with no arguments.")
                        appendLine("     *")
                        appendLine("     * @param callback Function to execute on worker thread")
                        appendLine("     * @returns Promise that resolves with the worker's return value")
                        appendLine("     *")
                        appendLine("     * @example With value")
                        appendLine("     * task(() => \"step1\")")
                        appendLine("     *     .thenTask(result => result + \"-step2\")")
                        appendLine("     *     .then(result => console.log(result)); // \"step1-step2\"")
                        appendLine("     *")
                        appendLine("     * @example With undefined (no argument)")
                        appendLine("     * Promise.resolve()")
                        appendLine("     *     .thenTask(() => \"from-worker\")")
                        appendLine("     *     .then(result => console.log(result)); // \"from-worker\"")
                        appendLine("     */")
                        appendLine("    thenTask<U>(callback: (value: T) => U): Promise<U>;")
                        appendLine()
                        appendLine("    /**")
                        appendLine("     * Chain with a tick delay, passing the result through.")
                        appendLine("     * Equivalent to: .then(result => wait(ticks).then(() => result))")
                        appendLine("     *")
                        appendLine("     * @param ticks Number of game ticks to wait")
                        appendLine("     * @returns Promise that resolves with the same value after the delay")
                        appendLine("     *")
                        appendLine("     * @example")
                        appendLine("     * task(() => 42)")
                        appendLine("     *     .thenWait(20) // Wait 1 second")
                        appendLine("     *     .then(result => console.log(result)); // 42 (preserved)")
                        appendLine("     */")
                        appendLine("    thenWait(ticks: number): Promise<T>;")
                        append("}")
                    }
                }
                "wait" -> null  // wait() is generated together with task()
                "schedule" -> null  // schedule() is deprecated/removed
                else -> null
            }
        } catch (e: Exception) {
            println("Warning: Failed to generate definition for $name: ${e.message}")
            null
        }
    }

    /**
     * Generate Structure API definition dynamically via reflection.
     * Introspects the actual StructureAPI and NBTAPI classes to generate method signatures.
     */
    private fun generateStructureApiDefinition(): String? {
        return try {
            // Verify Structure API is initialized
            val structureWrapper = ScriptEngine.structureAPI ?: return null

            // Access the underlying StructureAPI via reflection
            val structureApiField = structureWrapper.javaClass.getDeclaredField("structureApi")
            structureApiField.isAccessible = true
            val structureApi = structureApiField.get(structureWrapper) as StructureAPI

            // Get NBTAPI instance
            val nbtApi = structureApi.getNbtApi()

            // Introspect StructureAPI methods
            val structureMethods = ReflectionIntrospector.introspectJavaObject(structureApi)
                .filter { it.name in setOf("list", "read", "write") }

            // Introspect NBTAPI methods
            val nbtMethods = ReflectionIntrospector.introspectJavaObject(nbtApi)
                .filter { it.name in setOf("forEach", "filter", "find", "some") }

            buildString {
                // Generate supporting interfaces

                // NBTFilterResult is a real Kotlin data class - introspect it
                val filterResultClass = NBTAPI.FilterResult::class.java
                val filterResultProperties = filterResultClass.declaredFields
                    .filter { !it.isSynthetic && !java.lang.reflect.Modifier.isStatic(it.modifiers) }
                    .map { field ->
                        val fieldName = field.name
                        val fieldType = when (fieldName) {
                            "path" -> "(string | number)[]"  // Better type for path
                            else -> TypeMapper.toTypeScript(field.genericType)
                        }
                        ReflectionIntrospector.PropertySignature(fieldName, fieldType, readonly = true)
                    }

                appendLine("interface NBTFilterResult {")
                filterResultProperties.forEach { prop ->
                    appendLine("    ${prop.name}: ${prop.type};")
                }
                appendLine("}")
                appendLine()

                // Include static NBT structure type definitions from resources
                // These are version-specific (Minecraft 1.21.1) and hand-crafted for accuracy
                val nbtStructureTypes = loadStaticNBTStructureTypes()
                appendLine(nbtStructureTypes)
                appendLine()

                // Generate main Structure interface using introspected methods
                appendLine("declare const Structure: {")

                // Add introspected methods with better parameter names
                structureMethods.forEach { method ->
                    // Use better parameter names for known methods
                    val signature = when (method.name) {
                        "list" -> "pool?: string"
                        "read" -> "name: string"
                        "write" -> "name: string, data: StructureData"
                        else -> method.parameters.joinToString(", ") { param ->
                            val paramName = param.name
                            val optional = if (param.optional) "?" else ""
                            if (paramName.startsWith("...")) {
                                "$paramName: ${param.type}"
                            } else {
                                "$paramName$optional: ${param.type}"
                            }
                        }
                    }

                    // Override return type for known methods with better types
                    val returnType = when (method.name) {
                        "list" -> "string[]"
                        "read" -> "StructureData | null"
                        "write" -> "void"
                        else -> method.returnType
                    }

                    appendLine("    ${method.name}($signature): $returnType;")
                }

                // Generate nested nbt object with better callback signatures
                appendLine("    nbt: {")
                nbtMethods.forEach { method ->
                    // Use better signatures for known NBT methods
                    val signature = when (method.name) {
                        "forEach" -> "data: any, callback: (value: any, path: (string | number)[], parent: any) => void"
                        "filter" -> "data: any, predicate: (value: any, path: (string | number)[], parent: any) => boolean"
                        "find" -> "data: any, predicate: (value: any, path: (string | number)[], parent: any) => boolean"
                        "some" -> "data: any, predicate: (value: any, path: (string | number)[], parent: any) => boolean"
                        else -> method.parameters.joinToString(", ") { param ->
                            val paramName = param.name
                            val optional = if (param.optional) "?" else ""
                            if (paramName.startsWith("...")) {
                                "$paramName: ${param.type}"
                            } else {
                                "$paramName$optional: ${param.type}"
                            }
                        }
                    }

                    // Override return type for known methods with better types
                    val returnType = when (method.name) {
                        "forEach" -> "void"
                        "filter" -> "NBTFilterResult[]"
                        "find" -> "NBTFilterResult | null"
                        "some" -> "boolean"
                        else -> method.returnType
                    }

                    appendLine("        ${method.name}($signature): $returnType;")
                }
                appendLine("    };")
                appendLine("};")
            }
        } catch (e: Exception) {
            println("Warning: Failed to generate Structure API definition: ${e.message}")
            e.printStackTrace()
            null
        }
    }



    /**
     * Generate README with IDE setup instructions.
     */
    private fun generateReadme(file: Path, hasGlobals: Boolean) {
        val content = buildString {
            appendLine("# RhettJS TypeScript Definitions")
            appendLine()
            appendLine("Auto-generated type definitions for IDE autocomplete.")
            appendLine()
            appendLine("**Generated**: ${LocalDateTime.now()}")
            appendLine()
            appendLine("## Files")
            appendLine()
            appendLine("- `rhettjs.d.ts` - Core RhettJS APIs (console, logger, task, schedule, Structure, Caller, Args)")
            appendLine("- `jsconfig.json.template` - VSCode project configuration template")
            appendLine()
            appendLine("## IDE Setup")
            appendLine()
            appendLine("### Visual Studio Code")
            appendLine()
            appendLine("**Option 1: Project-Wide (Recommended)**")
            appendLine()
            appendLine("1. Copy the template:")
            appendLine("   ```bash")
            appendLine("   cp rjs/__types/jsconfig.json.template rjs/jsconfig.json")
            appendLine("   ```")
            appendLine("2. Reload VSCode (Cmd/Ctrl + Shift + P â†’ \"Reload Window\")")
            appendLine("3. All scripts now have autocomplete!")
            appendLine()
            appendLine("**Option 2: Per-File**")
            appendLine()
            appendLine("Add to the top of your script:")
            appendLine("```javascript")
            appendLine("/// <reference path=\"../__types/rhettjs.d.ts\" />")
            if (hasGlobals) {
                appendLine("/// <reference path=\"../__types/rhettjs-globals.d.ts\" />")
            }
            appendLine("```")
            appendLine()
            appendLine("### IntelliJ IDEA / WebStorm")
            appendLine()
            appendLine("**Automatic** - Should work out of the box!")
            appendLine()
            appendLine("If not:")
            appendLine("1. Right-click `rjs/__types/` folder")
            appendLine("2. Mark Directory As â†’ **Resource Root**")
            appendLine("3. File â†’ Invalidate Caches â†’ Restart (if needed)")
            appendLine()
            appendLine("### Other IDEs")
            appendLine()
            appendLine("Most IDEs with TypeScript/JavaScript support will auto-discover `.d.ts` files.")
            appendLine("If not, add reference directives (see VSCode Option 2 above).")
            appendLine()
            appendLine("## Testing Autocomplete")
            appendLine()
            appendLine("Create a test script and type:")
            appendLine()
            appendLine("```javascript")
            appendLine("console.    // Should show: log, info, warn, error")
            appendLine("Structure.  // Should show: read, write, list")
            appendLine("```")
            appendLine()
            if (hasGlobals) {
                appendLine("For custom globals:")
                appendLine("```javascript")
                appendLine("new MessageBuffer()  // Should show constructor and methods")
                appendLine("```")
                appendLine()
            }
            appendLine("If you see suggestions, autocomplete is working! ðŸŽ‰")
            appendLine()
            appendLine("## Notes")
            appendLine()
            appendLine("- **Core APIs** are dynamically introspected and accurate")
            appendLine("- **Structure/NBT types** match the official Minecraft NBT structure format")
            appendLine("- **Custom globals** are introspected at runtime - complex patterns may need manual refinement")
            appendLine("- **Re-generate** by running `/rjs probe` in-game")
            appendLine("- **Manually edit** `rhettjs-globals.d.ts` if auto-generated types aren't perfect")
            appendLine()
            appendLine("## Examples")
            appendLine()
            appendLine("See example scripts at:")
            appendLine("- `docs/example-scripts/` (in repository)")
            appendLine("- GitHub: https://github.com/your-org/RhettJS/tree/main/docs/example-scripts")
            appendLine()
            appendLine("## More Information")
            appendLine()
            appendLine("- RhettJS Documentation: `docs/`")
            appendLine("- API Reference: `docs/api/`")
            appendLine("- GitHub: https://github.com/your-org/RhettJS")
        }

        Files.writeString(file, content)
    }

    /**
     * Generate jsconfig.json.template for VSCode.
     */
    private fun generateJsConfigTemplate(file: Path) {
        val content = """{
  "compilerOptions": {
    "target": "ES5",
    "module": "commonjs",
    "checkJs": false,
    "allowJs": true,
    "noEmit": true,
    "moduleResolution": "node"
  },
  "include": [
    "scripts/**/*.js",
    "server/**/*.js",
    "startup/**/*.js",
    "globals/**/*.js"
  ],
  "exclude": [
    "node_modules"
  ]
}
"""
        Files.writeString(file, content)
    }

    /**
     * Result of type generation.
     */
    sealed class GenerationResult {
        data class Success(
            val filesGenerated: Int,
            val coreApiCount: Int,
            val globalsCount: Int
        ) : GenerationResult()

        data class Error(
            val message: String,
            val exception: Exception
        ) : GenerationResult()
    }

}
